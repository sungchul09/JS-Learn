### [SECTION5 execution Context]

---

#### L23 - 실행 콘텍스트 / 실행 콘텍스트 상태 컴포넌트

---

```javascript
function music(title){
  var musicTitle = title;
};
music('음악')
```

1. 실행 콘텍스트

   * 함수가 실행되는 영역, 묶음
   * 함수 코드를 실행하고 실행 결과를 저장
   * 스팩상의 사양이다. (즉, 개발자가 실행 콘텍스트의 뭔가를 바꿀수는없고 엔진이 처리하는 부분이다.)
   * music('음악')으로 함수를 호출하면 엔진은 실행 콘텍스트를 생성하고 실행 콘텍스트 안으로 이동한다.
   * 실행 콘텍스트 실행단계
     * 준비, 초기화, 코드실행 단계
   * 실행 콘텍스트 생성 시점
     * 실행 가능한 코드를 만났을 때
   * 실행 가능한 코드 유형
     * 함수 코드, 글로벌 코드, eval 코드
   * 코드 유형을 분리한 이유는 실행 콘텍스트에서 처리 방법과 실행 환경이 다르기 때문이다.
     * 함수 코드: 렉시컬 환경
     * 글로벌 코드: 글로벌 환경
     * eval 코드: 동적 환경

2. 실행 콘텍스트 상태 컴포넌트

   ``` javascript
   실행 콘텍스트(EC): {
     렉시컬 환경 컴포넌트(LEC): {
       //이 안에 프로퍼티 형태로 작성
     },
     변수 환경 컴포넌트(VEC): {},
     this 바인딩 컴포넌트(TBC): {}
   }
   ```

   * 실행 콘텍스트 상태를 위한 오브젝트 (실행 콘텍스트 안에 생성)
     * 렉시컬 환경 컴포넌트 (LEC)
     * 변수 환경 컴포넌트 (VEC)
     * this 바인딩 컴포넌트 (TBC)



#### L24 - 렉시컬 환경 컴포넌트 / 렉시컬 환경 컴포넌트 구성,설정 / 외부 렉시컬 환경 참조 / 변수 환경 컴포넌트

---

1. 렉시컬 환경 컴포넌트
   * 함수와 변수의 식별자 해결을 위한 환경 설정
   * 함수 초기화 단계에서 해석한 함수, 변수를 {name: value} 형태로 저장한다.
   * 변수 {name: undefined}, 함수{name: function 오브젝트}
     즉, 이름으로 함수와 변수를 검색할 수 있게 된다.
   * 함수 밖의 함수와 변수를 참조할 수 있는 환경을 설정한다.
     즉, 함수 밖의 함수, 변수를 사용할 수 있게 된다.

2. 렉시컬 환경 컴포넌트 구성

   ```javascript
   실행 콘텍스트(EC): {
     렉시컬 환경 컴포넌트(LEC): {
   		환경 레코드(ER):{
         point: 100
       },
       외부 렉시컬 환경 참조(OLER): {
         title: "책",
         getTitle: function(){}
       }
     }
   }
   ```

   * 렉시컬 환경 컴포넌트 생성
     * function, with, try-catch에서 생성
   * 컴포넌트 구성
     * 환경 레코드(ER: Environment Record)
     * 외부 렉시컬 환경 참조(OLER: Outer Lexical Environment Reference)

3. 렉시컬 환경 컴포넌트 설정

   * 환경 레코드(ER)에 함수 안의 함수와 변수를 기록
   * 외부 렉시컬 환경 참조(OLER)에 function 오브젝트의 [[Scope]]를 설정한다.
   * 따라서, 함수 안과 밖의 함수와 변수를 사용할 수 있게 된다.

4. 외부 렉시컬 환경 참조

   * 스코프와 실행중인 함수가 Context 형태이다.
   * 스코프의 변수와 함수를 별도의 처리없이 즉시 사용할수있다.
   * 실행 콘텍스트에서 함수 안과 밖의 함수, 변수를 사용할 수 있으므로 함수 변수를 찾기위해 실행 콘텍스트를 벗어나지 않아도 된다.

5. 변수 환경 컴포넌트

   ```javascript
   실행 콘텍스트(EC): {
   	렉시컬 환경 컴포넌트(LEC): {},
     변수 환경 컴포넌트(VEC): {},
     this 바인딩 컴포넌트(TBC): {}
   }
   ```

   * 실행 콘텍스트 초기화 단계에서 렉시컬 환경 컴포넌트와 같게 설정한다.
   * 초기값을 복원할때 사용하기 위한 것이다. 
     * 함수코드가 실행되면 실행결과를 LEC에 설정한다. 
     * 초기값이 변하게 되므로 이를 유지하기 위한 것.



#### L25 - 실행콘텍스트 실행 과정

``` javascript
var base = 200;
function getPoint(bonus){
  	var point = 100;
  	return point + base + bonus;
}
console.log(getPoint(70));
```

1. 실행 과정
   * getPoint 오브젝트의 [[Scope]]에 글로벌 오브젝트를 설정

   * getPoint() 함수 호출

   * 엔진은 실행 콘텍스트 생성 -> 실행 콘텍스트 안으로 이동

   * ---준비단계---

   * 컴포넌트를 생성해 실행 콘텍스트에 첨부한다.

     * 렉시컬 환경 컴포넌트
     * 변수 환경 컴포넌트
     * this 바인딩 컴포넌트

     ```javascript
     실행 콘텍스트(EC):{
         렉시컬 환경 컴포넌트(LEC): {},
         변수 환경 컴포넌트(VEC): {},
         this 바인딩 컴포넌트(TBC): {}
     }
     ```

   * 환경 레코드를 생성해 렉시컬 환경 컴포넌트에 첨부

     * 함수 안의 함수, 변수를 바인딩한다.

       ```javascript
       실행 콘텍스트(EC): {
           렉시컬 환경 컴포넌트(LEC) = {
               환경 레코드(ER): {}
           },
           변수 환경 컴포넌트(VEC): {},
           this 바인딩 컴포넌트(TBC): {}
       }
       ```

     * 외부 렉시컬 환경 참조를 생성하여 렉시컬 환경 컴포넌트에 첨부하고 function 오브젝트의 [[Scope]]를 설정한다.

       ```javascript
       실행 콘텍스트(EC): {
           렉시컬 환경 컴포넌트(LEC) = {
               환경 레코드(ER): {},
               외부 렉시컬 환경 참조(OLER): {
                   base: 200
               }
           },
           변수 환경 컴포넌트(VEC): {},
           this 바인딩 컴포넌트(TBC): {}
       }
       ```

   * ------ 초기화 단계 -----

   * 호출한 함수의 파라미터값을 호출된 함수의 파라미터 이름에 매핑 -> 환경 레코드에 작성 (여기까지는 외부 실행 상태를 제공하지 않는다.)

     ```javascript
     실행 콘텍스트(EC): {
         렉시컬 환경 컴포넌트(LEC) = {
             환경 레코드(ER): {
                 bonus: 70,
                 point: undefined
             },
             외부 렉시컬 환경 참조(OLER): {
                 base: 200
             }
         },
         변수 환경 컴포넌트(VEC): {},
         this 바인딩 컴포넌트(TBC): {}
     }
     ```

   * ----- 실행단계 -----

   * 함수 안의 코드를 실행한다. (var point = 100;)

   * 실행 콘텍스트 안에서 관련된 함수와 변수를  사용할 수 있다.

   

#### L26 - 환경 레코드 구성

----

1. 환경 레코드 구성

   ``` javascript
   실행 콘텍스트(EC): {
   	랙시컬 환경 컴포넌트(LEC):{
           환경 레코드(ER): {
               선언적 환경 레코드(DER): { //function 변수, catch 문
                   point: 123
               },
               오브젝트 환경 레코드(OER): { //글로벌 함수,변수, with문 (동적)
                   
               }
           },
           외부 렉시컬 환경 참조(OLER): {}
       },
       변수 환경 컴포넌트(VEC):{},
       this 바인딩 컴포넌트(TBC): {}
   }
   ```

   * 환경 레코드를 구분하는 이유는 기록 대상이 다르기 때문이다.
   * 선언적 환경 레코드
     * DER : Declarative Environment Record
     * function, 변수, catch 문에서 사용한다.
     * 앞 절에서 환경 레코드에 설정한다고 했는데 설명을 위한 것이었다.
       실제로는 여기에 설정한다.
   * 오브젝트 환경 레코드
     * OER: Object Environment Record
     * 글로벌 함수와 변수, with 문에서 사용한다.
     * 정적이 아니라 동적이기 때문이다.

2. 글로벌 환경

   ```javascript
   실행 콘텍스트(EC):{
       글로벌 환경(GE):{ // 글로벌 오브젝트
           환경레코드(ER):{
               오브젝트 환경 레코드: 글로벌 오브젝트
           },
           외부 렉시컬 환경 참조(OLER): null
       }
   }
   ```

   * Global Environment
     * 글로벌 오브젝트에서 사용
     * 렉시컬 환경 컴포넌트와 형태 같음
   * 동적으로 함수와 변수를 바인딩한다.
     * 함수에서 var 키워드를 사용하지않고 변수를 선언하면 글로벌 오브젝트에 선언되기 때문이다.
     * 이런 이유로 오브젝트 환경 레코드를 사용한다.
   * 외부 렉시컬 환경 참조 값은 항상 null이다.



#### L27 - this 바인딩 컴포넌트

---

1. this 바인딩 컴포넌트

   * 목적
     * this로 함수를 호출한 오브젝트의 프로퍼티에 엑세스
       (ex. this.propertyName)
   * 엑세스 매커니즘
     * obj.book() 형태여서 this로 obj를 참조할 수 있도록
     * this 바인딩 컴포넌트에 obj 참조를 설정
   * obj의 프로퍼티가 변경되면 동적으로 참조
     * 설정이 아닌 참조이기 때문이다.

2. 예시

   ```javascript
   var obj = {point: 100};
   obj.getPoint = function(){
   	return this.point;
   };
   obj.getPoint();
   ```

   ```javascript
   실행 콘텍스트:{
   	렉시컬 환경 컴포넌트{
           환경레코드(ER):{
               선언적 환경 레코드(DER):{},
               오브젝트 환경 레코드(OER): {}
           }
       },
       변수 환경 컴포넌트:{
           
       },
       this 바인딩 컴포넌트:{
           point: 100,
           getPoint: function(){}
       }
   }
   ```

   * 준비단계
     * 마지막 줄에서 obj.getPoint() 함수 호출
     * 실행 콘텍스트 생성
     * 3개의 컴포넌트 생성
       렉시컬 환경 컴포넌트 / 변수 환경 컴포넌트 / this 바인딩 컴포넌트
     * this 바인딩 컴포넌트에 getPoint()에서 this로 obj의 프로퍼티를 사용할 수 있도록 바인딩
   * 초기화단계
     * 파라미터, 함수 선언문, 변수 선언 없는 상태
   * 실행 단계
     * return this.point; 실행
     * this 바인딩 컴포넌트에서 point 검색
       (getPoint() 함수를 호출한 오브젝트가 this 바인딩 컴포넌트에 설정(참조)된 상태)
   * 추가설명
     * obj.getPoint()에서 obj의 프로퍼티가 this 바인딩 컴포넌트에 바인딩되도록 의도적으로 설계해야한다.



#### L28 - 호출 스택(call stack)

---

1. 호출 스택
   * call stack
     * 실행 콘텍스트의 논리적 구조
   * First In Last Out 순서
     * 함수가 호출되면 스택의 가장 위에 실행 콘텍스트가 위치한다.
     * 다시 함수 안에서 함수를 호출하면 호출된 함수의 실행 콘텍스트가
       스택의 가장 위에 놓이게 된다.
     * 함수가 종료되면 스택에서 빠져나온다 (FILO)
     * 가장 아래는 글로벌 오브젝트의 함수가 위치해있다.



#### L29 - 파라미터 매핑 / 함수 호출 / 파라미터 값 매핑 / 파라미터 이름에 값 매핑 방법

---

1. 함수 호출
   * 함수가 호출되면 3개의 파라미터 값을 실행 콘텍스트로 넘겨준다.
     * 함수를 호출한 오브젝트
     * 함수 코드
     * 호출한 함수의 파라미터 값
   * 함수를 호출한 오브젝트를 this 바인딩 컴포넌트에 설정해 this로 참조한다.
   * 함수 코드는 function 오브젝트의 [[Code]]에 설정되어 있다.
   * 호출한 함수의 파라미터 값은 호출된 함수의 Argument 오브젝트에 설정한다.

2. 파라미터 값 매핑

   * 파라미터 값 매핑이란 ?
     * 호출한 함수에서 넘겨 준 파라미터 값을 호출된 함수의 파라미터 작성 순서에 맞추어 값을 매핑하는 것
   * 엔진처리 관점에서 실행 콘텍스트로 넘겨준 파라미터 값과 function 오브젝트의 [[FormalParameters]]에 작성된 이름에 값을 매핑하고 결과를 선언적 환경 레코드에 설정하는 것

3. 파라미터 이름에 값 매핑 방법

   ``` javascript
   var obj = {};
   obj.getTotal = function(one, two) {
   	return one + two;
   };
   console.log(obj.getTotal(11,22,77));
   ```

   * getTotal 오브젝트의 [[FormalParameters]]에서 호출된 함수의 파라미터 이름을 구한다.(설명 편의를 위해 name이라고 하자.)
     * name은 ["one", "two"] 형태이다.
     * [[FormalParameters]]는 function 오브젝트를 생성할 때 설정한다.
   * name 배열을 하나씩 읽는다.
   * param에서 index 번째의 값을 구한다.
     * index에 값이 없으면 undefined 반환

   * name의 파라미터 이름과 4번에서 구한 값을 선언적 환경 레코드에



#### L30 - 파라미터 값 할당 기준

---

1. 파라미터 값 할당 기준

   ``` javascript
   var obj = {};
   obj.getTotal = function(one, two){
       var one;
       console.log(one + two);
       two = 77;
       console.log("two:"+ two);
   }
   obj.getTotal(11, 22);
   ```

   * 초기화 단계
     * obj.getTotal(11,22) 함수가 호출되면 파라미터 값을 실행 콘텍스트로 넘겨준다.
     * 파라미터 이름에 값을 매핑하여 선언적 환경 레코드에 설정한다.
       {one: 11, two: 22}
     * var one;
       선언적 환경 레코드에서 one의 존재를 체크한다. 파라미터 이름을 설정하였으므로 존재하며 one을 기록하지 않는다.
     * two = 77;
       선언적 환경 레코드에서 two의 존재를 체크한다. 파라미터 이름을 설정하였으므로 존재하며 two를 기록하지 않는다.
     * 함수에 초기화할 코드가 없으므로 첫째줄로 이동해 함수 코드를 실행한다.
   * 실행 단계
     * 선언적 환경 레코드는 {one: 11, two:22} 상태
     * var one;
       단지, 변수 선언이므로 처리하지 않는다.
     * console.log(one + two);
       선언적 환경 레코드에서 one과 two의 값을 구한다.
       11 + 22의 결과인 33이 [실행 결과]에 출력된다.
     * two = 77;
       값을 할당하는 코드이며 실행 단계이므로 선언적 환경 레코드의 two에 77을 할당한다. ({two:22}가  {two:77} 로 변경)
     * console.log("two: "+ two);
       선언적 환경 레코드에서 two의 값을 구한다. (two: 77이 출력된다.)



### [SECTION6 this 바인딩 컴포넌트]

#### L31 -

---



#### L32 -

---



#### L33 -

---



#### L34 -

---



#### L35 -

---



#### L36 -

---



#### L37 -

---



#### L38 -

---



### [SECTION7 this]

#### L39 -

---



#### L40 -

---



#### L41 -

---



#### L42 -

---



#### L43 -

---



#### L44 -

---



#### L45 -

---



#### L46 -

---



### [SECTION8 논리적 정리]

#### L47 -

---



#### L48 -

---



#### L49 -

---



#### L50 -

---





